import fs from 'fs';
import * as readline from 'readline'
//import * as events from 'events'
const events = require('events');

const input = './data/voxel-generic-image-upstream-colibri-imx7.cve'
interface IssueType {
    layer: string | undefined,
    package_name: string,
    package_version: string | undefined,
    cve: string | undefined,
    cve_status: string | undefined,
    cve_summary: string | undefined,
    cvss_v2_base_score: string | undefined,
    cvss_v3_base_score: string | undefined,
    vector: string | undefined,
    more_information: string | undefined
}

class Reader {
    issues: Map<string, IssueType> = new Map<string, IssueType>()

    private issue: any = {} //< private to accumulate
    private inCVESummary: boolean = false

    stats: any = {} 

    /** insert issue into hashmap and collect a few statistics on cve status types
     * 
     * @param i 
     */
    insert(i: IssueType) {
        this.issues.set(i.layer + ':' + i.package_name, this.issue as IssueType)
        if (! this.stats[i.cve_status!]) {
            this.stats[i.cve_status!] = 1
        } else {
            this.stats[i.cve_status!] ++
        }
    }

    /** accumulate single lines into one issue object; insert into issues once an empty line is detected
     * 
     * @param line 
     * @returns 
     */
    accumulate(line: string) {
        if (line.length == 0 && !this.inCVESummary) {
            console.log('SPLIFF', this.issue)

            this.insert(this.issue as IssueType)
            this.issue = {}
            return
        }
        console.log(line)
        let kv = line.split(':')
        let n = kv[0].toLocaleLowerCase().replace(/ /g, '_')

        // CVE SUMMARY multi-line handling: lines might be multi-line (thank you, openssl / CVE-2023-0215 )
        // AND it likes to have many empty lines...
        // we assume that cvss_v2_base_score is the next key to appear after summary
        if (kv.length < 2) {
            if (this.inCVESummary) {
                this.issue.cve_summary += line.trim() + '\n'
                return
            } else {
                console.log('ERROR CANNOT DEAL WITH SHORT LINE ' + line)
            }
        }
        if (this.inCVESummary) {
            // exit only if cvss_v2_base_score marker found!
            if ( n === 'cvss_v2_base_score') {
                this.inCVESummary                 = false
                let val = kv[1].trim()
                this.issue[n] = val
                return
            }
            this.issue.cve_summary += '\n' + line
            console.log('SUM CONT2 ', line)
            return
        }
        if (kv.length >= 2) {
            // deal with multiple : in text
            let val = line.substring(line.indexOf(':') + 1).trim()
            this.issue[n] = val
        }
    }
    /** read in a potentially large file with issue descriptions
     * 
     * @param file 
     */
    async read(file: string) {
        try {
            const rl = readline.createInterface({
                input: fs.createReadStream(file),
                crlfDelay: Infinity
            });

            rl.on('line', (line) => {
                this.accumulate(line)
            });

            await events.once(rl, 'close');
        } catch (err) {
            console.error(err);
        }
    }
}

let r = new Reader;

r.read(input)
    .then(() => { 
        console.log('STATS', r.stats)

    })
    .catch(e => {
        console.log('ERR ' + e)
    })
