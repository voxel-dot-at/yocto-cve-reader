import fs from 'fs';
import * as readline from 'readline'
//import * as events from 'events'
const events = require('events');

let input = './data/voxel-generic-image-upstream-colibri-imx7.cve'

if (process.argv.length >= 3) { 
    input = process.argv[process.argv.length - 1] 
    console.log('READING', input)
}

interface IssueType {
    layer: string | undefined,
    package_name: string,
    package_version: string | undefined,
    cve: string | undefined,
    cve_status: string | undefined,
    cve_summary: string | undefined,
    cvss_v2_base_score: string | undefined,
    cvss_v3_base_score: string | undefined,
    vector: string | undefined,
    more_information: string | undefined
}

class Reader {
    issues = new Map<string, IssueType>()

    private issue: any = {} //< private to accumulate
    private inCVESummary: boolean = false

    stats: any = {}
    count = 0
    unpatched = new Array<IssueType>()

    /** insert issue into hashmap and collect a few statistics on cve status types
     * 
     * @param i 
     */
    insert(i: IssueType) {
        this.issues.set(i.layer + ':' + i.package_name, this.issue as IssueType)
        if (!this.stats[i.cve_status!]) {
            this.stats[i.cve_status!] = 1
        } else {
            this.stats[i.cve_status!]++
        }
        if (i.cve_status! === 'Unpatched') {
            this.unpatched.push(i)
        }
    }

    /** accumulate single lines into one issue object; insert into issues once an empty line is detected
     * 
     * @param line 
     * @returns 
     */
    accumulate(line: string) {
        if (line.length == 0 && !this.inCVESummary) {
            this.insert(this.issue as IssueType)
            this.issue = {}
            return
        }

        let kv = line.split(':')
        let n = kv[0].toLocaleLowerCase().replace(/ /g, '_')

        // CVE SUMMARY multi-line handling: lines might be multi-line (thank you, openssl / CVE-2023-0215 )
        // AND it likes to have many empty lines...
        // we assume that cvss_v2_base_score is the next key to appear after summary
        if (kv.length < 2) {
            if (this.inCVESummary) {
                this.issue.cve_summary += line.trim() + '\n'
                return
            } else {
                console.log('ERROR CANNOT DEAL WITH SHORT LINE ' + line)
            }
        }
        if (this.inCVESummary) {
            // exit only if cvss_v2_base_score marker found!
            if (n === 'cvss_v2_base_score') {
                this.inCVESummary = false
                let val = kv[1].trim()
                this.issue[n] = val
                return
            }
            this.issue.cve_summary += '\n' + line
            return
        }
        if (kv.length >= 2) {
            // deal with multiple : in text
            let val = line.substring(line.indexOf(':') + 1).trim()
            this.issue[n] = val
            if (!this.inCVESummary) { // there may be lines with multiple in the summary
                this.inCVESummary = n === 'cve_summary'
            }
        }
    }
    /** read in a potentially large file with issue descriptions
     * 
     * @param file 
     */
    async read(file: string) {
        try {
            const rl = readline.createInterface({
                input: fs.createReadStream(file),
                crlfDelay: Infinity
            });

            rl.on('line', (line) => {
                this.accumulate(line)
            });

            await events.once(rl, 'close');
        } catch (err) {
            console.error(err);
        }
    }
}

let r = new Reader;

r.read(input)
    .then(() => {
        console.log('STATS', r.stats)
        console.log('***** UNPATCHED')
        for (let i of r.unpatched) {
            console.log(`${ i.layer }:${ i.package_name }_${ i.package_version }  ${ i.cve } ${ i.cvss_v2_base_score } ${ i.cvss_v3_base_score }`)
            console.log(`\t${ i.cve_summary }`)
        }

    })
    .catch(e => {
        console.log('ERR ' + e)
    })
